{% extends "base.html" %}
{% block content %}
    <link href="/css/slideAction.css" rel="stylesheet" />

    <table class="table" style=display:inline-table;">
      <thead>
        <tr>
            <th scope="col" style="white-space: nowrap;">食材</th>
            <th scope="col" style="white-space: nowrap;">人</th>
            <th scope="col" style="white-space: nowrap;">部屋</th>
            <th scope="col" style="white-space: nowrap;">賞味期限</th>
            <th></th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>卵</td>
          <td>Kota</td>
          <td>204</td>
          <td>2023/04/10</td>
            <td><span class="fa-solid fa-trash"></span></td>
        </tr>
        <tr>
          <td>牛乳</td>
          <td>Masato Yano</td>
          <td>204</td>
          <td>2023/04/10</td>
            <td><span class="fa-solid fa-trash"></span></td>
        </tr>
        <tr>
          <td>バター</td>
          <td>ようえ</td>
          <td>204</td>
          <td>2023/04/10</td>
            <td><span class="fa-solid fa-trash"></span></td>
        </tr>
      </tbody>
    </table>
    <script>
    import TinyGesture from "https://unpkg.com/tinygesture@1.1.4/TinyGesture.js";
    // Documentation: https://www.npmjs.com/package/tinygesture

    function initSlider(target) {
      let swiped = false;
      let startOffset = 0;
      const decelerationOnOverflow = 4;
      const revealWidth = 50;
      const snapWidth = revealWidth / 1.5;

      const gesture = new TinyGesture(target);

      // swipe gestures
      gesture.on("panmove", (event) => {
        if (gesture.animationFrame) {
          return;
        }
        event.preventDefault();
        gesture.animationFrame = window.requestAnimationFrame(() => {
          let getX = (x) => {
            if (x < revealWidth && x > -revealWidth) {
              return x;
            }
            if (x < -revealWidth) {
              return (x + revealWidth) / decelerationOnOverflow - revealWidth;
            }
            if (x > revealWidth) {
              return (x - revealWidth) / decelerationOnOverflow + revealWidth;
            }
          };
          const newX = getX(startOffset + gesture.touchMoveX);
          target.style.transform = "translateX(" + newX + "px)";
          if (newX >= snapWidth || newX <= -snapWidth) {
            swiped = newX < 0 ? -revealWidth : revealWidth;
          } else {
            swiped = false;
          }
          window.requestAnimationFrame(() => {
            target.style.transition = null;
          });
          gesture.animationFrame = null;
        });
      });

      gesture.on("panend", () => {
        window.cancelAnimationFrame(gesture.animationFrame);
        gesture.animationFrame = null;
        window.requestAnimationFrame(() => {
          target.style.transition = "transform .2s ease-in";
          if (!swiped) {
            startOffset = 0;
            target.style.transform = null;
          } else {
            startOffset = swiped;
            target.style.transform = "translateX(" + swiped + "px)";
          }
        });
      });

      // reset on tap
      gesture.on("doubletap", (event) => {
        // we could also use 'doubletap' here
        window.requestAnimationFrame(() => {
          target.style.transition = "transform .2s ease-in";
          swiped = false;
          startOffset = 0;
          target.style.transform = null;
        });
      });
    }

    document.addEventListener("DOMContentLoaded", () => {
      document.querySelectorAll(".swipe-item").forEach(initSlider);
    });
    </script>
{% endblock %}